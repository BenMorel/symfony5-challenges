extending_chapter1a:
  question: |
    How do we create a simple Symfony application using the command line?
  explanation: |
    The recommended way to create Symfony applications is to use the `symfony` binary, but
    you can also create a new project using Composer as well.
  features:
    multiple_choice:
      choices:
        a: `symfony new my_project`
        b: `composer create-symfony skeleton my_project`
        c: `composer create-project symfony/skeleton my_project`
        d: Both A & C
      correct: d

extending_chapter1b:
  question: |
    What package does not come with the default Symfony skeleton application?
  explanation: |
    `symfony/skeleton` does not require `symfony/http-kernel` package directly, but it requires the
    `symfony/framework-bundle` package that in turn requires `symfony/http-kernel` and a few more.
    So, with `symfony/skeleton` you get `symfony/http-kernel` out-of-the-box!
  features:
    multiple_choice:
      choices:
        a: `symfony/console`
        b: `symfony/framework-bundle`
        c: `symfony/http-kernel`
        d: All packages listed above are included in `symfony/skeleton`
      correct: d

extending_chapter2a:
  question: |
    Which file is the default front controller in Symfony 5 applications?
  features:
    multiple_choice:
      choices:
        a: `public/app.php`
        b: `public/index.php`
        c: `src/Controller/DefaultController.php`
        d: `composer.json`
      correct: b

extending_chapter2b:
  question: |
    What command does NOT run the local web server?
  explanation: |
    Both `symfony serve` and `symfony server:start` allow you to run the local web server.
    The difference is that the last command just does not block your terminal and run it in
    the background. You can achieve the same with `symfony serve -d`.
  features:
    multiple_choice:
      choices:
        a: `php -S 127.0.0.1:8000 -t public/`
        b: `symfony server:start`
        c: `symfony serve`
        d: All commands above run the local web server
      correct: d

extending_chapter3a:
  question: |
    Where is the default routes configurtation file located in Symfony 5 applciations?
  features:
    multiple_choice:
      choices:
        a: `src/routes.yaml`
        b: `composer.json`
        c: `public/index.php`
        d: `config/routes.yaml`
      correct: d

extending_chapter3b:
  question: |
    What should every controller function return?
  features:
    multiple_choice:
      choices:
        a: Any content as a `string` type
        b: An instance of `Symfony\Component\HttpFoundation\Response`
        c: `null`
        d: An action
      correct: b

extending_chapter4:
  question: |
    What is the correct way to define wildcards for routes?
  features:
    multiple_choice:
      choices:
        a: `@Route("/user/{username}")`
        b: `@Route("/blog/*.")`
        c: `@Route("/user/<username>")`
        d: `@Route("/user/(username)")`
      correct: a

extending_chapter5:
  question: |
    How can you list all the registered routes in your application using the console?
  explanation: |
    Symfony's `bin/console` is very useful! Run `bin/console list debug` to see the list of all
    commands avialable that could help you with debugging.
  features:
     multiple_choice:
       choices:
         a: `bin/console debug:routes`
         b: `bin/console debug:router`
         c: `bin/console router:show`
         d: `bin/console routes:list`
       correct: b

extending_chapter6a:
  question: |
    Symfony Flex is:
  explanation: |
    Correct! Symfony Flex is the way to manage Symfony applications, but it's implemented
    as a simple Composer plugin that is based on Symfony Recipes, which are a set of automated
    instructions to integrate third-party packages into Symfony applications.
  features:
    multiple_choice:
      choices:
        a: A Symfony component
        b: A Composer plugin
        c: A methodology of development for new Symfony projects
      correct: b

extending_chapter6b:
  question: |
    What package does correspond to the `security-check` alias in
    `composer require security-check` when you use Symfony Flex?
  explanation: |
    If you’re not sure, you can always check it on the `https://flex.symfony.com/` website.
    In there you can search by package name or tag!
  features:
    multiple_choice:
      choices:
        a: The `sensiolabs/security-checker` package
        b: The `security/check` package
        c: The `symfony/security` package
        d: The `symfony/requirements-checker` package
      correct: a

extending_chapter8a:
  question: |
    - Where are templates stored by default in a Symfony 5 application?
  features:
    multiple_choice:
      choices:
        a: app/Resources/views/
        b: app/templates/
        c: templates/
        d: src/Resources/views/
      correct: c

extending_chapter8b:
  question: |
    What is the correct naming convention for a Twig HTML page?
  explanation: |
    Correct! The reason we use the two extensions after the template name is to remind
    us that this `twig` file will be processed into something we intend to show
    as `HTML`, for example, in a web page!
  features:
    multiple_choice:
      choices:
        a: layout.html
        b: layout.twig
        c: layout.html.twig
        d: layout.twig.html
      correct: c

extending_chapter8c:
  question: |
    Suppose we have a project that has a `data/` folter that exists at the root.
    How can we build an absolute path in a Yaml configuration file that points to such path?
  explanation: |
    `%kernel.project_dir%` is a special configuration parameter that returns the absolute path of
    the root directory of your Symfony project. You can use that to build custom paths relative to
    the project’s root directory!
  features:
    multiple_choice:
      choices:
        a: `./data`
        b: `%kernel.project_dir%/data`
        c: `%kernel.root_dir%/data`
        d: `%kernel.data_dir%`
      correct: b

extending_chapter9a:
  question: |
    Suppose we have a basic controller that extends
    `Symfony\Bundle\FrameworkBundle\Controller\AbstractController`. In it, there's an action
    that renders a template. The controller
    would look like this:

    ```php
    class MyController extends AbstractController
    {
        /**
         * @Route("/mypage")
         */
        public function myPage()
        {
            return $this->render('myPAge.html.twig');
        }
    }
    ```

    In this case, what does `$this->render` return?
  explanation:
    A Symfony Controller route action is a PHP function that you create that reads
      information from the Request object and creates and returns a Response object.
      It should always return an instance of `Symfony\Component\HttpFoundation\Response`
  features:
    multiple_choice:
      choices:
        a: An HTML code as a string that was rendered with Twig service
        b: An object of type `Symfony\Component\HttpFoundation\Response`
        c: An instance of a Twig template
        d: Depends on specified flags on `render()` method call
      correct: b

extending_chapter9b:
  question: |
    Which of this lines is NOT correct Twig syntax?
  features:
    multiple_choice:
      choices:
        a: `{{ price }}`
        b: `{% set language = 'PHP' %}`
        c: `{* comment *}`
        d: `{# incorrect #}`
      correct: c

extending_chapter9c:
  question: |
    What is the correct Twig syntax to iterate over an array?
  explanation: |
    To iterate over an array in Twig, you need to use the `{% for comment in comments %}` syntax.

    > Similar to PHP, where you can get array keys using the syntax
    > `foreach ($comments as $index => $comment)`, you can use the Twig form:
    >   `{% for index, comment in comments %}`
    > where `index` is the key of the `comment` value.
  features:
    multiple_choice:
      choices:
        a: `{% foreach comments as comment %}`
        b: `{% for comments as comment %}`
        c: `{% for index, comment in comments %}`
        d: `{% for comments => comment %}`
      correct: c

extending_chapter10a:
  question: |
    What will happen if you call the `dump()` PHP function with out any arguments?
  explanation: |
    That's right. Calling it without arguments will print all the available variables *only*
    when you call it inside a Twig template! If you call this function in a PHP file -
    it will throw an error: `Too few arguments to function dump(), 0 passed and exactly 1 expected`.
  features:
    multiple_choice:
      choices:
        a: An error will be thrown as at least one argument is required
        b: It will print all known variables available at the line where it was called
        c: Nothing, this call will be just ignored, i.e. it returns an empty result
        d: System information will be printed
      correct: a

extending_chapter10b:
  question: |
    What can the Symfony Profiler NOT help you with out-of-the-box?
  explanation: |
    The Symfony Profiler and the Web Debug Toolbar that you can see when you are in `dev` mode at
    the bottom of any page are just your best friends! They give you a lot of useful information.
  features:
    multiple_choice:
      choices:
        a: Explain performance of your application with execution timeline
        b: See logs that were created during the request
        c: Know what events were dispatched during the request
        d: See translations that were used during the request
        e: Symfony Profiler can help you with everything listed above
      correct: e

extending_chapter11:
  question: |
    Suppose we are working on a Twig template and we need to add a link that points to the file
    `checkout.css`, which is stored at `public/css`. How would you do that?
  explanation: |
    It's always a bad idea to hardcode relative paths in your templates. Using the `asset()` Twig
    function will help you build *any* link relative to the `public/` directory correctly.
  features:
    multiple_choice:
      choices:
        a: |
          `<link href="{{ asset('css/checkout.css') }}">`
        b: |
          `<link href="{{ css('checkout.css') }}">`
        c: |
          `<link href="public/css/checkout.css">`
        d: Both A & C
      correct: a

extending_chapter12:
  question: |
    Let's say I'm creating a route in my controller that needs to be called `app_user_profile` so
    that I can build links to it in a Twig template. What is the correct annotation syntax to do it?
  features:
    multiple_choice:
      choices:
        a: |
          `@Route("/user/profile", "app_user_profile")`
        b: |
          `@Route("/user/profile", name:app_user_profile)`
        c: |
          `@Route("/user/profile", name="app_user_profile")`
        d: |
          `@Route("/user/profile", name=app_user_profile)`
      correct: c

extending_chapter13:
  question: |
    Suppose I have a simple controller that extends
    `Symfony\Bundle\FrameworkBundle\Controller\AbstractController`. This time, in one of its actions,
    I want to return a JSON response instead of HTML. What would the return statement look like?
  features:
    multiple_choice:
      choices:
        a: `return $this->json([/* … */])`
        b: `return new JsonResponse([/* … */])`
        c: `return json_encode([/* … */])`
        d: Both A & B are correct
      correct: d

extending_chapter14:
  question: |
    Suppose I have a Twig block in a template that has some content in it:

    ```twig
    {% block myBlock %}
        Some content here!
    {% endblock %}
    ```

    I now want to *extend* it inside a child template without it removing the parent's content.
    What is the correct way to do that?
  explanation: |
    That's right! Adding `parent()` inside a block will print its parent's contents so that
    they don't get replaced!
  features:
    multiple_choice:
      choices:
        a: {{ block('parent') }}
        b: {{ append() }}
        c: {{ parent() }}
        d: {% parent() %}
      correct: c

extending_chapter15a:
  question: |
    What is the correct way make the route `@Route("/api/articles/{id}")`
    API endpoint only accessible to GET requests?
  features:
    multiple_choice:
      choices:
        a: `@Route("/api/articles/{id}", method="GET")`
        b: `@Route("/api/articles/{id}", methods="GET")`
        c: `@Route("/api/articles/{id}", methods=["GET"])`
        d: `@Route("/api/articles/{id}", "GET")`
      correct: b

extending_chapter15b:
  question: |
    Which of these routes will match the request if you open the following URL in a browser?
    `https://localhost/admin/user/victor`
  explanation: |
    When you open a page in a browser, the browser sends a simple GET request. POST requests are more
    complex though. You can send them via AJAX or using HTML forms setting their `action` atribute to `POST`.
  features:
    multiple_choice:
      choices:
        a: @Route("/user/{victor}")
        b: @Route("/admin/user/{username}", methods="POST")
        c: @Route("/admin/user/{username}", methods="GET")
        d: Both B & C
      correct: c

extending_chapter16:
  question: |
    What type hint do you need to use to inject a Twig service into your controller’s endpoint
    using the service's autowiring feature to be able it to render tempaltes?
  explanation: |
    That's right! `\Twig\Environment` is the correct service name for getting the Twig instance
    to render templates.
  features:
    multiple_choice:
      choices:
        a: `public function myEndpoint(\Twig\Environment $twig)`
        b: `public function myEndpoint(\Twig\Template $twig)`
        c: `public function myEndpoint(Twig\Twig $twig)`
        d: `public function myEndpoint(Twig\Renderer $twig)`
      correct: a

extending_chapter18:
  question: |
    What is the correct way to run Webpack Encore?
  explanation: |
    `yarn watch` is just a shortcut for running `yarn run encore dev --watch`. You can see it defined
    in your `package.json`.
  features:
    multiple_choice:
      choices:
        a: `yarn watch`
        b: `encore run`
        c: `yarn run encore dev --watch`
        d: Both A & C
      correct: d
